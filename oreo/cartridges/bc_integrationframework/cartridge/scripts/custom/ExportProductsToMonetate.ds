/**
 * Export Products to Monetate 
 * @input ExportFile : String The export file name
 * @output ErrorMsg : String The error message if any
 */

importPackage(dw.catalog);
importPackage(dw.system);
importPackage(dw.util);
importPackage(dw.io);

importScript("custom/ExportUtils.ds");
importScript("converse_core:constants.ds");
importScript("converse_core:product/PriceResolver.ds");
importScript("converse_core:product/ProductImageResolver.ds");
importScript("converse_core:product/ProductUtils.ds");

var logger : Logger               = Logger.getLogger('ExportMonetate'),
    PriceResolver : Object        = converse.product.PriceResolver,
    ProductImageResolver : Object = converse.product.ProductImageResolver;

function execute(args : PipelineDictionary) : Number
{
    let errorMsg : String = null;
    
    try {
        monetateFeed(args.ExportFile, ProductMgr.queryAllSiteProducts());
        return PIPELET_NEXT;
    } catch(e) {
        errorMsg = e.toString();
        args.ErrorMsg = errorMsg;
        logger.error(errorMsg);
        return PIPELET_ERROR;
    }
}

function monetateFeed(filename: String , products : SeekableIterator) {

    let categories = function(out : XMLIndentingStreamWriter, product : Product) {
        let iterateCategories = function (categories : Collection) {
            let iterator : Iterator = categories.iterator();
            while (iterator.hasNext()) {
                let category : Category = iterator.next(); 
                out.writeStartElement("category");
                simpleNode(out , "category_id" , category.getID());
                simpleNode(out , "category_name" , category.getDisplayName());
                out.writeEndElement();
            }
        }
        let categories : Collection = (empty(product.getOnlineCategories())) ? 
            product.getMasterProduct().getOnlineCategories() : product.getOnlineCategories() ;
        if (! empty(categories) ) {
            out.writeStartElement("categories") ;
            iterateCategories(categories) ;
            out.writeEndElement() ;
        }
    }

    let initWriter = function (file) {
        let out : XMLIndentingStreamWriter = new XMLIndentingStreamWriter(new FileWriter(file, "UTF-8"));
        out.setIndent("  ");
        out.writeStartDocument();
        out.writeStartElement("catalog");
        simpleNode(out , "version" , "5");
        return out;
    }

    let finalizeWriter = function (out : XMLIndentingStreamWriter) {
        try {
            out.writeEndElement();
            out.writeEndDocument();
        } finally {
            if (null != out) {
                out.flush();
                out.close();
            }
        }
    }

    let makeProductNode = function (out : XMLIndentingStreamWriter, product : Product ) {
        if (null == product) {
            return;
        }
        out.writeStartElement("product");
        populateProductData(out, product);
        out.writeEndElement();
    }

    let main = function(filename: String , products : SeekableIterator) {
        let file = new File(filename);
        let out = initWriter(file);
        let setOfSkus = new HashSet();

        while(products.hasNext()) {
            let product = products.next();
            
            if (setOfSkus.contains(product.manufacturerSKU)) {
                continue;
            } else {
                setOfSkus.add(product.manufacturerSKU);
            }

            if (product.online && product.variant) {
                makeProductNode(out, product); 
            }
        }

        finalizeWriter(out);
    }

    function price(out : XMLIndentingStreamWriter, product : Product) {
        let pricing : Object = PriceResolver.getProductPricing(product);
        if (PriceResolver.isSalesPriceAvailable(pricing)) {
            simpleNode(out , "price" , pricing.salesPrice);
            simpleNode(out , "alt_price" , 
                PriceResolver.isStandardPriceAvailable(pricing) ? pricing.standardPrice : '0.0');
        } else {
           simpleNode(out , "price" , 
                PriceResolver.isStandardPriceAvailable(pricing) ? pricing.standardPrice : '0.0');
        }
    }

    let populateProductData = function(out : XMLIndentingStreamWriter, product : Product ) {
        simpleNode(out , "product_id" , product.manufacturerSKU);
        simpleNode(out , "product_name" , product.name);
        simpleNode(out , "product_description" , "Converse");
        skus(out, product);
        simpleNode(out , "brand_name" , "CONVERSE");
        categories(out, product);
        price(out, product);
        simpleNode(out , "url" , ProductUtils.getProductLink(product.ID));
        productImageUrl(out , product );
        simpleNode(out , "availability" , product.availabilityModel.orderable ? 'In Stock' : 'Out Of Stock');
    }

    let productImageUrl = function (out : XMLIndentingStreamWriter, product : Product) {
        let imageUrl : Object = ProductImageResolver.getProductImage(product, 'large', 0);
        
        if (!empty(imageUrl)){
            simpleNode(out , "product_image_url" , imageUrl.getURL());
        }
    }

    let simpleNode = function(out : XMLIndentingStreamWriter, nodeName : String , value : String) {
        out.writeStartElement(nodeName);
        out.writeCharacters(value);
        out.writeEndElement();
    }

    let skus = function(out : XMLIndentingStreamWriter, product : Product) {
        out.writeStartElement("skus");
        simpleNode(out , "sku" , product.manufacturerSKU);
        out.writeEndElement();
    }

    main(filename , products);
}

