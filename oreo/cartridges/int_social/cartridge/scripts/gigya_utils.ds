importPackage(dw.system);
importPackage(dw.net);
importPackage(dw.crypto);
importPackage(dw.util);

importScript("converse_core:common/libInheritance.ds");
importScript("converse_core:common/libNamespace.ds");
importScript("converse_core:util/TimeUtils.ds");

function gigya(){} 

(function() {

    var DEFAULT_BASE_URL : String = "https://socialize.gigya.com",
        DEFAULT_TIMEOUT : Number = 5000;

    var logger : Logger = Logger.getLogger('Gigya');
    
    var GetRequest = Class.extend({
        
        init: function(url : String) {
            this.url = url;
        },
        
        getUrl: function() : String {
            return this.url;
        },
        
        process: function() : Object {
            var response;
            
            try {
                let httpClient : HTTPClient = new HTTPClient();
                httpClient.setTimeout(DEFAULT_TIMEOUT);
                httpClient.open("GET", this.getUrl());
                httpClient.send();
                
                if (httpClient.statusCode == 200) {
                    response = new GetResponse(this, httpClient.getText(), null);
                }
                else {
                    let errorMessage : String = StringUtils.format("Request failed with status code: {0} and status message: {1}", httpClient.statusCode, httpClient.statusMessage);
                    response = new GetResponse(this, null, errorMessage);
                }
            }
            catch(e) {
                response = new GetResponse(this, null, e.toString());
            }
            
            return response;
        }
        
    });
    
    var GetResponse = Class.extend({
    
        init: function(request : Object, responseText : String, errorMessage : String) {
            this.request = request;
            this.responseText = responseText;
            this.errorMessage = errorMessage;
        },
        
        getRequest: function() : Object {
            return this.request;
        },
        
        getUrl: function() : String {
            return this.getRequest().getUrl();
        },
        
        getResponseText: function() : String {
            return this.responseText;
        },
        
        getResponseJSON: function() : Object {
            return JSON.parse(this.getResponseText());
        }, 
        
        getErrorMessage: function() : String {
            return this.errorMessage;
        },
        
        isSuccess: function() {
            return empty(this.getErrorMessage());
        }
        
    });
    
    var Client = Class.extend({
        
        doGet: function(url) : Object {
            
            var request = new GetRequest(url);
            
            logger.debug("Sending request to URL: {0}", request.getUrl());
            
            var response = request.process();
            
            if (!response.isSuccess()) {
                logger.error("Error processing request to URL: {0}, message: {1}", response.getUrl(), response.getErrorMessage());
            }
            
            return response;
        }
        
    });
    
    var Utils = {
    
        checkKeys: function() : Boolean {
            if (empty(Site.current.preferences.custom.gigya_secretkey) || empty(Site.current.preferences.custom.gigya_apikey)) {
                logger.error("Gigya API and/or Secret Keys are unavailable");
                return false;
            }
            
            return true;
        },
        
        executeGet: function(url : String, successCallback : Function, errorCallback : Function) : Number {
            if (Utils.checkKeys()) {
                var result = Utils.doGet(url);
                
                var callback : Function = result.isSuccess() ? successCallback : errorCallback,
                    code : Number = result.isSuccess() ? PIPELET_NEXT : PIPELET_ERROR;
                
                if (callback) {
                    callback(result);
                }
                
                return code;
            }
            
            return PIPELET_ERROR;
        },
        
        doGet: function(url : String) : Object {
            var client = new Client();
            return client.doGet(url);
        }, 
        
        prepareUrl: function(path : String, params : Object) : String {
            var baseUrl : String = DEFAULT_BASE_URL,
                cleanPath : String = path.charAt(0) === '/' ? path.substring(1) : path,
                requiredParams : String = Utils.serialize({
                    "apiKey": Site.current.preferences.custom.gigya_apikey,
                    "secret": Site.current.preferences.custom.gigya_secretkey,
                    "format": "json"
                });
            
            var url : String = baseUrl + "/" + cleanPath + "?" + requiredParams;
            
            if (!empty(params)) {
                url += "&" + Utils.serialize(params);
            }
            
            return url;
        },
        
        serialize: function(obj, prefix) : String {
            var pairs : Array = [];
            for (let p in obj) {
                if (obj.hasOwnProperty(p)) {
                    var k = prefix ? prefix + "[" + p + "]" : p,
                        v = obj[p];
                    
                    if (typeof v === "object" && v !== null) {
                        pairs.push(Utils.serialize(v, k));
                    }
                    else {
                        pairs.push(encodeURIComponent(k) + "=" + (empty(v) ? "" : encodeURIComponent(v)));
                    }
                }
            }
            return pairs.join("&");
        },
        
        isSignatureExpired: function(timestamp : Number) : Boolean {
            var currentDate : Date = TimeUtils.getUTCTime();
            var sigDate = new Date(timestamp * 1000);
            var currentSeconds = Date.UTC(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), 
                                            currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds()) / 1000;
            
            // validate that the timestamp is less than 3 minutes old
            if (Math.abs(currentSeconds - timestamp) > 180) {
                return true;
            }
            
            return false;
        }, 
        
        generateSignature: function(uid : String, timestamp : Number) : String {
            var secretKey : String = Site.current.preferences.custom.gigya_secretkey;
            var baseString = timestamp.toString() + '_' + uid;
            
            var signatureBytes = new Bytes(baseString);
            var keyBytes = Encoding.fromBase64(secretKey);
            
            var cryptoMac = new Mac(Mac.HMAC_SHA_1);
            var gigyaloginBytes = cryptoMac.digest(signatureBytes, keyBytes);
            var gigyaSignature = Encoding.toBase64(gigyaloginBytes);
            
            return gigyaSignature;
        },
        
        verifySignature: function(uid : String, timestamp : Number, signature : String) : Boolean {
            var verified : Boolean = false;
            
             try {
                if (Utils.isSignatureExpired(timestamp)) {
                    logger.warn('Gigya signature timestamp expired for UID: {0}', uid);
                }
                else {
                    let gigyaSignature : String = Utils.generateSignature(uid, timestamp);
                    
                    verified = gigyaSignature === signature;
                    
                    if (!verified) {
                       logger.error('Invalid Gigya signature: {0} for UID: {1}', signature, uid);
                    }
                }
            }
            catch(e) {
                logger.error(e.toString());
            }
            
            return verified;
        }
    };
    
    Namespace.extend(gigya, { 
        Client: Client, 
        Utils: Utils 
    });

})();
