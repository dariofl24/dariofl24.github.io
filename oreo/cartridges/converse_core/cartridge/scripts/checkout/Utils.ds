/**
 * This script provides utility functions shared across other checkout scripts.
 * Reused script components for checkout should be contained here, while this
 * script is imported into the requiring script.
 */
importPackage( dw.customer );
importPackage( dw.order );
importPackage( dw.system );
importPackage( dw.util );
importPackage( dw.value );

importScript("constants.ds");

/**
 * Calculates the amount to be payed by a non-gift certificate payment instrument based 
 * on the given basket. The method subtracts the amount of all redeemed gift certificates 
 * from the order total and returns this value.
 */
function calculateNonGiftCertificateAmount( basket : Basket ) 
{
    // the total redemption amount of all gift certificate payment instruments in the basket
    var giftCertTotal : Money = new Money( 0.0, basket.currencyCode );

    // get the list of all gift certificate payment instruments 
    var gcPaymentInstrs : Collection = basket.getGiftCertificatePaymentInstruments();
    var iter : Iterator = gcPaymentInstrs.iterator();
    var orderPI : OrderPaymentInstrument = null;

    // sum the total redemption amount
    while( iter.hasNext() )
    {
        orderPI = iter.next();
        giftCertTotal = giftCertTotal.add( orderPI.getPaymentTransaction().getAmount() );
    }

    // get the order total
    var orderTotal : Money = basket.totalGrossPrice;

    // calculate the amount to charge for the payment instrument
    // this is the remaining open order total which has to be paid
    var amountOpen : Money = orderTotal.subtract( giftCertTotal );

    // return the open amount
    return amountOpen;
}

/**
 * Determines a unique shipment ID for shipments in the given basket
 * and the given base ID. The function appends a counter to the base ID
 * and checks the existence of the resulting ID. If the resulting ID is
 * unique this ID is returned, if not the counter is incremented and
 * checked again.
 */
function determineUniqueShipmentID( basket : Basket, baseID : String )
{
    var counter : Number = 1;
    var shipment : Shipment = null;
    var candidateID : String = baseID + "" + counter;
    while( shipment == null )
    {
        shipment = basket.getShipment(candidateID);
        if( shipment != null )
        {
            // this ID is already taken, increment the counter 
            // and try the next one
            counter++;
            candidateID = baseID + "" + counter;
            shipment = null;
        }
        else
        {
            return candidateID;
        }
    }
    
    // should never go here
    return null;
}

/**
 * Transient representation of a shipping address.
 */
function ShippingAddress()
{
    var UUID : String = null;

    var ID : String = null;
    var firstName : String = null;
    var lastName : String = null;
    var address1 : String = null;
    var address2 : String = null;
    var city : String = null;
    var postalCode : String = null;
    var stateCode : String = null;
    var countryCode : String = null;
    var phone : String = null;

    /**
     * The UUID of the reference address. It is set when the attributes
     * are copied from a given customer or order address and is used
     * to preselect addresses on a per product line item base.
     */
    var referenceAddressUUID : String = null;

    /**
     * Copies the attributes of this address to the given order address.
     */ 
    this.copyTo = function( toAddress : OrderAddress )
    {
        toAddress.setFirstName( this.firstName );
        toAddress.setLastName( this.lastName );
        toAddress.setAddress1( this.address1 );
        toAddress.setAddress2( this.address2 );
        toAddress.setCity( this.city );
        toAddress.setPostalCode( this.postalCode );
        toAddress.setStateCode( this.stateCode );
        toAddress.setCountryCode( this.countryCode );
        toAddress.setPhone( this.phone );
    }

    /**
     * Copies the attributes from the given customer address or
     * order address to this address. The function supports both
     * copying from CustomerAddress as well as from OrderAddress.
     */
    this.copyFrom = function( fromAddress : CustomerAddress )
    {
        // if we copy from a customer address, we set the address ID
        if( fromAddress instanceof CustomerAddress )
        {
            this.ID = fromAddress.ID;
        }
        
        this.firstName = fromAddress.firstName;
        this.lastName = fromAddress.lastName;
        this.address1 = fromAddress.address1;
        this.address2 = fromAddress.address2;
        this.city = fromAddress.city;
        this.postalCode = fromAddress.postalCode;
        this.stateCode = fromAddress.stateCode;
        this.countryCode = fromAddress.countryCode;
        this.phone = fromAddress.phone;
    }
}

/**
 * Creates a new transient shipping address in the session dictionary.
 */
function createShippingAddress( referenceAddress : CustomerAddress )
{
    // create a new in memory address and set the UUID
    var address : Object = new ShippingAddress();
    address.UUID = UUIDUtils.createUUID();

    // get all addresses from session dictionary
    var addresses : Collection = session.custom.shippingAddresses;

    // create an empty array, if no collection was found in session dictionary
    if( addresses == null )
    {
        addresses = new ArrayList();
        session.custom.shippingAddresses = addresses;
    }

    // add the address to the collection
    addresses.add( address );

    // copy the attribute of the reference address to the transient address

    return address;
}

/**
 * Finds a transient shipping address in the session dictionary
 * and returns the found address.
 */
function findShippingAddress( uuid : String )
{
    // check if uuid is set
    if( empty(uuid) )
    {
        return null;
    }

    // get all addresses from session dictionary
    var addresses : Collection = session.custom.shippingAddresses;

    // check if there are addresses at all
    if( addresses == null || addresses.size() == 0 )
    {
        return null;
    }

    // find the address
    for(var i=0; i<addresses.size(); i++)
    {
        if( uuid.equals(addresses[i].UUID) )
        {
            return addresses[i];
        }    
    }

    return null;
}

/**
 * Removes a transient shipping address from the session dictionary.
 */
function removeShippingAddress( shippingAddress : Object )
{
    // check if shippingAddress is set
    if( empty(shippingAddress) )
    {
        return;
    }

    // get all addresses from session dictionary
    var addresses : Collection = session.custom.shippingAddresses;

    // check if there are addresses at all
    if( addresses == null || addresses.size() == 0 )
    {
        return;
    }

    // remove the object from the collection
    addresses.remove( shippingAddress );

    return;
}

/** 
 * Determines if the basket already contains payment 
 * instruments of the given payment method and removes them from the basket.
 */
function removeExistingPaymentInstruments( basket : Basket, method : String )
{
    // get all payment instruments
    var paymentInstrs : Collection = basket.getPaymentInstruments( method );
    var iter : Iterator = paymentInstrs.iterator();
    var existingPI : OrderPaymentInstrument = null;

    // remove them
    while( iter.hasNext() )
    {
        existingPI = iter.next();
        basket.removePaymentInstrument( existingPI );
    }
}

/** 
 * Removes all payment instruments from the basket EXCEPT
 * payment instruments of the given payment method.
 */
function removeAllExistingPaymentInstrumentsExcept( basket : Basket, method : String )
{
    // get all payment instruments
    var paymentInstrs : Collection = basket.getPaymentInstruments();
    var iter : Iterator = paymentInstrs.iterator();
    var existingPI : OrderPaymentInstrument = null;

    // identify if we have a payment instrument to keep
    var specifiedPaymentInstrs : Collection = basket.getPaymentInstruments( method );
    var paymentInstrumentToKeep : OrderPaymentInstrument = null;
    if ( !specifiedPaymentInstrs.isEmpty() ) {
        paymentInstrumentToKeep = specifiedPaymentInstrs.iterator().next();
    }

    // remove all that we should
    while ( iter.hasNext() ) {
        existingPI = iter.next();
        
        if ( existingPI !== paymentInstrumentToKeep ) {
            basket.removePaymentInstrument( existingPI );
        }
    }
}

function setOrderJourneysIds(order : Order, basketSummary) {
    if (basketSummary.getShipmentSummaryList().getLength() > 2) {
        throw new Error("The maximum number of basket summary shipments is 2 (DYO and/or Inline)");
    }
    
    var shipmentSummaryIter : Iterator = basketSummary.getShipmentSummaryList().iterator();
    while (shipmentSummaryIter.hasNext()) {
        var shipmentSummary = shipmentSummaryIter.next();
        var journeysOrderID : String = shipmentSummary.getJourneysOrderID();
        
        if (shipmentSummary.getProductType() === converse.constants.ProductType.C1) {
            order.custom.dyoJourneysOrderID = journeysOrderID;
        } 
        else {
            order.custom.inlineJourneysOrderID = journeysOrderID;
        }
    }
    
    var orderShipmentIter : Iterator = order.getShipments().iterator();
    while (orderShipmentIter.hasNext()) {
        var shipment : Shipment = orderShipmentIter.next();
        
        if (shipment.custom.productType === converse.constants.ProductType.C1) {
            shipment.custom.journeysOrderID = order.custom.dyoJourneysOrderID;
        } 
        else {
            shipment.custom.journeysOrderID = order.custom.inlineJourneysOrderID;
        }
    }
}

function getOrderJourneysIds(order : Order, separator : String) : String {
    var dyoOrderID : String = order.custom.dyoJourneysOrderID;
    var inlineOrderID : String = order.custom.inlineJourneysOrderID;
    
    if (empty(dyoOrderID) && empty(inlineOrderID)) {
        throw new Error("Order must have at least one Journeys order id set");
    }
    
    var ids : Array = [];
    
    if (!empty(dyoOrderID)) {
        ids.push(dyoOrderID);
    }
    
    if (!empty(inlineOrderID)) {
        ids.push(inlineOrderID);
    }
    
    return ids.join(separator || ", "); 
}


function getShippingDiscount(lineItemCtnr: LineItemCtnr) : Money {
    var shippingExclDiscounts : Money = lineItemCtnr.shippingTotalPrice;
    var shippingInclDiscounts : Money = lineItemCtnr.adjustedShippingTotalPrice;
    return shippingExclDiscounts.subtract( shippingInclDiscounts );
}

function getOrderDiscount(lineItemCtnr: LineItemCtnr) : Money {
    var merchTotalExclOrderDiscounts : Money = lineItemCtnr.getAdjustedMerchandizeTotalPrice(false);
    var merchTotalInclOrderDiscounts : Money = lineItemCtnr.getAdjustedMerchandizeTotalPrice(true);
    return merchTotalExclOrderDiscounts.subtract( merchTotalInclOrderDiscounts );
}

function setAttributesForArvato(order: Order, device: Object) {

    var itemsItr = order.productLineItems.iterator();

    while (itemsItr.hasNext()) {

        var lineItem = itemsItr.next();
        //get Product reference
        var product = lineItem.product;

        //set lineitem custom attributes
        lineItem.custom.altProductId = product.UPC;
        lineItem.custom.colorCode = product.custom.mainColorHex;
        lineItem.custom.colorName = product.custom.color;
        lineItem.custom.size = product.custom.size;
        lineItem.custom.styleSKU = lineItem.productID;
        lineItem.custom.productType = product.variationModel.master ? product.variationModel.master.custom.productType : product.custom.productType;
    }

    //set order level custom attributes
    order.custom.customerIP = order.remoteHost;

    if (device == "mobile") {
        order.custom.createdByDevice = converse.constants.ArvatoDeviceType.mobile;
    } else if (device == "tablet") {
        order.custom.createdByDevice = converse.constants.ArvatoDeviceType.tablet;
    } else {
        order.custom.createdByDevice = converse.constants.ArvatoDeviceType.desktop;
    }

    order.custom.orderClientID = converse.constants.ArvatoOrderClientId;
    order.custom.orderCreationDate = order.creationDate;
    order.custom.transferStatus = "PENDING";

}