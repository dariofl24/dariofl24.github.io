/**
 * @input Unit: Object
 */
importPackage(dw.system);
importPackage(dw.util);
importPackage(dw.value);

importScript("module_test:Framework/Assert.ds");
importScript("module_test:Framework/Unit.ds");

importScript("converse_core:constants.ds");
importScript("converse_core:common/libNamespace.ds");
importScript("converse_core:product/PriceBuilder.ds");

importScript("module_test:Library/JSMockito.ds");

function execute(args : PipelineDictionary) : Number {

    let PROMOTION_CLASS_PRODUCT: String = dw.campaign.Promotion.PROMOTION_CLASS_PRODUCT;
    let PriceBuilder: Object = converse.product.PriceBuilder;
    let LineItemPriceBuilder: Object = converse.product.LineItemPriceBuilder;
    let Curreny: String = Site.getCurrent().getCurrencyCode();

    function money(value: Number) : Money {
        return new Money(value, Curreny);
    }

    function formatMoney(money: Money) : String {
        return StringUtils.formatMoney(money);
    }

    function qty(value: Number) : Quantity {
        return new Quantity(value, "items");
    }

    function emptyCollection() : Collection {
        return new ArrayList();
    }

    function createPriceTable(quantities: Collection) : Object {
        return Mockito.mock({
            getQuantities: function() : Collection {
                return quantities || new ArrayList();
            }
        });
    }

    function createProductPromotions(promotionalClass: String, promotionalPrice: Money) : Collection {
        let promotions: ArrayList = new ArrayList();
        promotions.add({
            getPromotionClass: function() {
                return promotionalClass;
            },
            getPromotionalPrice: function(product: Product) {
                return promotionalPrice;
            }
        });
        return promotions;
    }

    function createVaraitionModel(variants: Collection) : Object {
        return Mockito.mock({
            getVariants: function() {
                return variants;
            }
        });
    }

    function createProduct(props: Object) : Object {
        let variations:Collection = props["variations"] || emptyCollection();

        return Mockito.mock({
            master: props["master"],
            getPriceModel: function() : Object {
                return props["priceModel"];
            },
            getVariationModel: function() {
                return createVaraitionModel(variations);
            }
        });
    }

    function createLineItem(props: Object) : Object {
        return Mockito.mock({
            getAdjustedPrice: function() {
                return props["lineItemPrice"];
            },
            getQuantityValue: function() : Number {
                return props["quantity"];
            },
            getProduct: function() {
                return props["product"];
            }
        });
    }

    function createPriceModel(props: Object) : Object {
        return Mockito.mock({
            getPrice: function() : Money {
                return props["salesPrice"];
            },
            getPriceBookPrice: function(priceBookID: String) : Money {
                return props["priceBookPrice"];
            },
            isPriceRange: function() : Boolean {
                return !!props["isPriceRange"];
            },
            getMinPrice: function() {
                return props["minPrice"];
            },
            getMaxPrice: function() {
                return props["maxPrice"];
            },
            getBasePriceQuantity: function() : Quantity {
                return qty(1);
            },
            getPriceTable: function() : Object {
                return createPriceTable();
            }
        });
    }

    function inject(module, name, dep) {
        let mockFunc = Mockito.mockFunction();
        Mockito.when(mockFunc)().thenReturn(dep);
        module[name] = mockFunc;
    }

    args.Unit.describe("PriceBuilder Test Suite")
        .test("Pricing with no product promotions and different sales and standard pricing", function () {
            var salesPrice: Money = money(10.5);
            var priceBookPrice: Money = money(12.5);

            var product: Object = createProduct({
                "master": false,
                "priceModel" : createPriceModel({
                    "salesPrice": salesPrice,
                    "priceBookPrice": priceBookPrice
                })
            });

            var priceBuilder: Object = new PriceBuilder(product);
            inject(priceBuilder, "getProductPromotions", emptyCollection());

            var pricing: Object = priceBuilder.getPricing();

            Assert.areEqual(pricing.salesPrice, salesPrice);
            Assert.areEqual(pricing.standardPrice, priceBookPrice);
            Assert.isTrue(pricing.showStandardPrice, "ShowStandardPrice should be true when sales and standard prices are different");
            Assert.isFalse(pricing.isPromoPrice, "When no product promotions available isPormoPrice should be false");
            Assert.areEqual(pricing.salesPriceFormatted, formatMoney(salesPrice));
            Assert.areEqual(pricing.standardPriceFormatted, formatMoney(priceBookPrice));
        })
        .test("When sales price and price book prices are equal then showStandardPrice should be false so that only one price is displayed", function () {
            var salesPrice: Money = money(10.5);
            var priceBookPrice: Money = money(10.5);

            var product: Object = createProduct({
                "master": false,
                "priceModel": createPriceModel({
                    "salesPrice": salesPrice,
                    "priceBookPrice": priceBookPrice
                })
            });

            var priceBuilder: Object = new PriceBuilder(product);
            inject(priceBuilder, "getProductPromotions", emptyCollection());

            var pricing: Object = priceBuilder.getPricing();

            Assert.areEqual(pricing.salesPrice, salesPrice);
            Assert.areEqual(pricing.standardPrice, priceBookPrice);
            Assert.isFalse(pricing.showStandardPrice, "ShowStandardPrice should be false when sales and standard prices are equal");
        })
        .test("When product has promotional price then this price is used as a sales price", function () {
            var salesPrice: Money = money(10.5);
            var priceBookPrice: Money = money(12.5);
            var promotionalPrice: Money = money(9.75);

            var product: Object = createProduct({
                "master": false,
                "priceModel": createPriceModel({
                    "salesPrice": salesPrice,
                    "priceBookPrice": priceBookPrice
                })
            });

            var priceBuilder: Object = new PriceBuilder(product);
            inject(priceBuilder,
                "getProductPromotions",
                createProductPromotions(PROMOTION_CLASS_PRODUCT, promotionalPrice)
            );

            var pricing: Object = priceBuilder.getPricing();

            Assert.areEqual(pricing.salesPrice, promotionalPrice);
            Assert.areEqual(pricing.standardPrice, salesPrice);
            Assert.isTrue(pricing.isPromoPrice, "isPormoPrice should be true to indicate that product has promotional price");
            Assert.isTrue(pricing.showStandardPrice, "When product has promotional price then showStandardPrice is true");
        })
        .test("When product has a promotion with class different than Promotion.PROMOTION_CLASS_PRODUCT then promotional price is not applied", function () {
            var salesPrice: Money = money(10.5);
            var priceBookPrice: Money = money(12.5);
            var promotionalPrice: Money = money(9.75);

            var product: Object = createProduct({
                "master": false,
                "priceModel": createPriceModel({
                    "salesPrice": salesPrice,
                    "priceBookPrice": priceBookPrice
                })
            });

            var priceBuilder: Object = new PriceBuilder(product);
            inject(priceBuilder,
                "getProductPromotions",
                createProductPromotions("RANDOM PROMOTIONAL CLASS", promotionalPrice)
            );

            var pricing: Object = priceBuilder.getPricing();

            Assert.areEqual(pricing.salesPrice, salesPrice);
            Assert.areEqual(pricing.standardPrice, priceBookPrice);
            Assert.isFalse(pricing.isPromoPrice, "isPormoPrice should be false when promotional class is different than Promotion.PROMOTION_CLASS_PRODUCT");
            Assert.isTrue(pricing.showStandardPrice, "showStandardPrice should still be true once sales price and price book prices are different");
        })
        .test("When master product which has no price range is passed to PriceBuilder then first variation is used to get a product for pricing calculation", function () {
            var salesPrice: Money = money(10.5);
            var priceBookPrice: Money = money(12.5);

            var variationProduct: Object = createProduct({
                "master": false,
                "priceModel": createPriceModel({
                    "salesPrice": salesPrice,
                    "priceBookPrice": priceBookPrice,
                    "isPriceRange": false
                })
            });

            var variants: Collection = new ArrayList();
            variants.add(variationProduct);

            var product: Object = createProduct({
                "master": true,
                "priceModel": createPriceModel({
                    "salesPrice": money(12.3),
                    "priceBookPrice": money(13.1),
                    "isPriceRange": false
                }),
                "variations": variants
            });

            var priceBuilder: Object = new PriceBuilder(product);
            inject(priceBuilder, "getProductPromotions", emptyCollection());

            var pricing: Object = priceBuilder.getPricing();

            Assert.areEqual(priceBuilder.product, variationProduct);
            Assert.areEqual(pricing.salesPrice, salesPrice);
            Assert.areEqual(pricing.standardPrice, priceBookPrice);
        })
        .test("When master product which HAS price range is passed to PriceBuilder then minPrice and maxPrice prices should be available in the pricing object", function () {
            var minPrice: Money = money(33.55);
            var maxPrice: Money = money(99.99);

            var product: Object = createProduct({
                "master": true,
                "priceModel": createPriceModel({
                    "salesPrice": money(10.5),
                    "priceBookPrice": money(12.5),
                    "minPrice": minPrice,
                    "maxPrice": maxPrice,
                    "isPriceRange": true
                })
            });

            var priceBuilder: Object = new PriceBuilder(product);
            inject(priceBuilder, "getProductPromotions", emptyCollection());

            var pricing: Object = priceBuilder.getPricing();

            Assert.isTrue(pricing.isPriceRange, "isPriceRange should be true");
            Assert.areEqual(pricing.minPrice, minPrice);
            Assert.areEqual(pricing.maxPrice, maxPrice);
        })
        .test("Given a product line item promotional price for the product should be taken from its line item's adjusted price", function () {
            var lineItemPrice: Money = money(19.65);
            var quantity: Number = 3;
            var salesPrice: Money = money(10.5);
            var priceBookPrice: Money = money(12.5);

            var product: Object = createProduct({
                "master": false,
                "priceModel": createPriceModel({
                    "salesPrice": salesPrice,
                    "priceBookPrice": priceBookPrice
                })
            });

            var lineItem: Object = createLineItem({
                "lineItemPrice": lineItemPrice,
                "quantity": quantity,
                "product": product
            });
            var lineItemPricePerUnit: Money = lineItemPrice.divide(quantity);

            var priceBuilder: Object = new LineItemPriceBuilder(lineItem);

            var pricing: Object = priceBuilder.getPricing();

            Assert.areEqual(priceBuilder.product, product);
            Assert.areEqual(pricing.salesPrice.value, lineItemPricePerUnit);
            Assert.areEqual(pricing.standardPrice.value, salesPrice);
            Assert.isTrue(pricing.isPromoPrice, "isPormoPrice should be true to indicate that product has promotional price");
            Assert.isTrue(pricing.showStandardPrice, "When product has promotional price then showStandardPrice is true");
        });

    return PIPELET_NEXT;
};
