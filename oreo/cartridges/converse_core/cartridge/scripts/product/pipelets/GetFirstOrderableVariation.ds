/*
* Returns the first orderable variation product for an input variation product to cover the case when the input product is not orderable
* 
* @input NonOrderableProduct : dw.catalog.Product
* @output Product : dw.catalog.Product
* @output CurrentVariationModel : dw.catalog.ProductVariationModel
*/

importPackage( dw.system );
importPackage( dw.catalog );
importPackage( dw.util );

function execute( args : PipelineDictionary ) : Number
{
    let nonOrderableProduct : Product = args.NonOrderableProduct;
    
    if (!nonOrderableProduct.variant) {
        return PIPELET_NEXT;
    }
    
    let masterProduct : Product = nonOrderableProduct.masterProduct;
    let pvm : ProductVariationModel = nonOrderableProduct.getVariationModel();
    
    let selectedColorVariationAttribute : ProductVariationAttribute = pvm.getProductVariationAttribute("color");
    let sizeVariationAttribute : ProductVariationAttribute = pvm.getProductVariationAttribute("size");
    
    let selectedColorVariationValue = pvm.getSelectedValue(selectedColorVariationAttribute);
    let allSizeVariationAttributesValues : Collection = pvm.getAllValues(sizeVariationAttribute);
    
    for each (let sizeVariationValue in allSizeVariationAttributesValues) {
        if (pvm.hasOrderableVariants(sizeVariationAttribute, sizeVariationValue)) {
            let filterMap : HashMap = new HashMap();
            filterMap.put(selectedColorVariationAttribute.getID(), selectedColorVariationValue.getValue());
            filterMap.put(sizeVariationAttribute.getID(), sizeVariationValue.getValue());
            
            args.Product = masterProduct.getVariationModel().getVariants(filterMap)[0]; //TODO: make sure we have only one item in the returned collection
            args.CurrentVariationModel = args.Product.getVariationModel();
            
            return PIPELET_NEXT;
        }
    }

    return PIPELET_NEXT;
}
